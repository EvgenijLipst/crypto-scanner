// index.ts - –ì–∏–±—Ä–∏–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞: CoinGecko (–º–∏–Ω–∏–º—É–º) + Helius (–∞–∫—Ç–∏–≤–Ω–æ)
import { config } from 'dotenv';
import { Database } from './database';
import { TelegramBot } from './telegram';
import { JupiterAPI } from './jupiter';
import { CoinGeckoAPI } from './coingecko';
import { TokenAnalyzer, AnalysisConfig } from './token-analyzer';
import { HeliusWebSocket } from './helius';
import { DiagnosticsSystem } from './diagnostics';
import { log } from './utils';

config();

// –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
const requiredEnvVars = [
  'DATABASE_URL',
  'TELEGRAM_TOKEN', 
  'TELEGRAM_CHAT_ID',
  'COINGECKO_API_KEY',
  'HELIUS_API_KEY'
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`‚ùå Missing required environment variable: ${envVar}`);
    process.exit(1);
  }
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
const db = new Database(process.env.DATABASE_URL!);
const tg = new TelegramBot(process.env.TELEGRAM_TOKEN!, process.env.TELEGRAM_CHAT_ID!);
const jupiter = new JupiterAPI();
const coingecko = new CoinGeckoAPI(process.env.COINGECKO_API_KEY!);
const helius = new HeliusWebSocket(process.env.HELIUS_API_KEY!, db, tg);

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
const analysisConfig: AnalysisConfig = {
  minTokenAgeDays: parseInt(process.env.MIN_TOKEN_AGE_DAYS || '14'),
  minLiquidityUsd: parseInt(process.env.MIN_LIQUIDITY_USD || '10000'),
  maxFdvUsd: parseInt(process.env.MAX_FDV_USD || '5000000'),
  minVolumeSpike: parseFloat(process.env.MIN_VOLUME_SPIKE || '3'),
  maxRsiOversold: parseInt(process.env.MAX_RSI_OVERSOLD || '35'),
  maxPriceImpactPercent: parseFloat(process.env.MAX_PRICE_IMPACT_PERCENT || '3'),
  priceImpactTestAmount: parseFloat(process.env.PRICE_IMPACT_TEST_AMOUNT || '10')
};

const tokenAnalyzer = new TokenAnalyzer(coingecko, jupiter, db, analysisConfig);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–∏—Å—Ç–µ–º—É –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
let diagnostics: DiagnosticsSystem;

// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è API
let apiUsageStats = {
  coingecko: {
    dailyUsage: 0,
    monthlyLimit: 10000,
    lastReset: new Date().toDateString()
  },
  helius: {
    dailyUsage: 0,
    monthlyLimit: 1000000,
    lastReset: new Date().toDateString()
  }
};

/**
 * –ï–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤ (CoinGecko - –º–∏–Ω–∏–º—É–º)
 */
async function dailyTokenRefresh() {
  try {
    log('üîÑ Daily token refresh starting...');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã CoinGecko
    const today = new Date().toDateString();
    if (apiUsageStats.coingecko.lastReset !== today) {
      apiUsageStats.coingecko.dailyUsage = 0;
      apiUsageStats.coingecko.lastReset = today;
    }
    
    if (apiUsageStats.coingecko.dailyUsage >= 300) { // –û—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–ø–∞—Å
      log('‚ö†Ô∏è CoinGecko daily limit reached, skipping refresh');
      return;
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ø —Ç–æ–∫–µ–Ω—ã –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    const tokens = await tokenAnalyzer.getTopTokensForMonitoring();
    apiUsageStats.coingecko.dailyUsage += 5; // –ü—Ä–∏–º–µ—Ä–Ω–æ 5 –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    
    log(`‚úÖ Daily refresh complete: ${tokens.length} tokens ready for monitoring`);
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç—á–µ—Ç
    await sendDailyReport(tokens.length);
    
  } catch (error) {
    log(`‚ùå Error in daily token refresh: ${error}`, 'ERROR');
    await tg.sendErrorMessage(`Daily Token Refresh Error: ${error}`);
  }
}

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—Ç Helius WebSocket
 */
async function handleHeliusSignal(mint: string, swapData: any) {
  try {
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞
    const result = await tokenAnalyzer.analyzeTokenActivity(mint, swapData);
    
    if (result && result.isSignal) {
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∏–≥–Ω–∞–ª –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
      await db.createSignal(
        result.mint,
        true, // is_buy
        result.data.volumeSpike || 0,
        result.data.rsi || 0
      );
      
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
      await sendSignalNotification(result);
      
      log(`‚úÖ Signal processed: ${result.symbol} (${result.mint})`);
    }
    
  } catch (error) {
    log(`‚ùå Error processing Helius signal: ${error}`, 'ERROR');
  }
}

/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–∏–≥–Ω–∞–ª–µ
 */
async function sendSignalNotification(signal: any) {
  try {
    const message = `üöÄ **BUY SIGNAL DETECTED** üöÄ

üíé **${signal.symbol}** (${signal.name})
üìç Mint: \`${signal.mint}\`

üìä **Analysis Results:**
‚Ä¢ Volume Spike: ${signal.data.volumeSpike?.toFixed(2)}x
‚Ä¢ RSI: ${signal.data.rsi?.toFixed(2)}
‚Ä¢ EMA Signal: ${signal.data.emaSignal ? '‚úÖ' : '‚ùå'}
‚Ä¢ Price Impact: ${signal.data.priceImpact?.toFixed(2)}%
‚Ä¢ Liquidity: $${signal.data.liquidity?.toLocaleString()}

üí∞ **Market Data:**
‚Ä¢ Price: $${signal.data.priceUsd?.toFixed(6)}
‚Ä¢ Market Cap: $${signal.data.marketCap?.toLocaleString()}
‚Ä¢ FDV: $${signal.data.fdv?.toLocaleString()}
‚Ä¢ Volume 24h: $${signal.data.volume24h?.toLocaleString()}

‚ö° **All criteria met - Ready to trade!**`;

    await tg.sendMessage(message);
    
  } catch (error) {
    log(`Error sending signal notification: ${error}`, 'ERROR');
  }
}

/**
 * –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –æ—Ç—á–µ—Ç
 */
async function sendDailyReport(tokensCount: number) {
  try {
    const message = `üìä **Daily Token Analysis Report**

üîÑ **System Status:**
‚Ä¢ Monitored Tokens: ${tokensCount}
‚Ä¢ Analysis Mode: Hybrid (CoinGecko + Helius)
‚Ä¢ Status: Active üü¢

üìà **API Usage:**
‚Ä¢ CoinGecko: ${apiUsageStats.coingecko.dailyUsage}/333 daily
‚Ä¢ Helius: ${apiUsageStats.helius.dailyUsage}/33,333 daily

‚öôÔ∏è **Configuration:**
‚Ä¢ Min Age: ${analysisConfig.minTokenAgeDays} days
‚Ä¢ Min Liquidity: $${analysisConfig.minLiquidityUsd.toLocaleString()}
‚Ä¢ Max FDV: $${analysisConfig.maxFdvUsd.toLocaleString()}
‚Ä¢ Min Volume Spike: ${analysisConfig.minVolumeSpike}x
‚Ä¢ Max RSI Oversold: ${analysisConfig.maxRsiOversold}
‚Ä¢ Max Price Impact: ${analysisConfig.maxPriceImpactPercent}%
‚Ä¢ Test Amount: $${analysisConfig.priceImpactTestAmount}

üéØ **Next daily refresh in ~24 hours**`;

    await tg.sendMessage(message);
    
  } catch (error) {
    log(`Error sending daily report: ${error}`, 'ERROR');
  }
}

/**
 * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
 */
async function initialize() {
  try {
    log('üöÄ Initializing Hybrid Solana Signal Bot...');
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    await db.initialize();
    log('‚úÖ Database initialized');
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
    diagnostics = new DiagnosticsSystem(db, tg);
    log('‚úÖ Diagnostics system initialized');
    
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ CoinGecko API
    log('üß™ Testing CoinGecko API...');
    const testTokens = await coingecko.getTopSolanaTokens(10);
    log(`‚úÖ CoinGecko API working - fetched ${testTokens.length} test tokens`);
    
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Jupiter API
    log('üß™ Testing Jupiter API...');
    const testQuote = await jupiter.getQuote(
      'So11111111111111111111111111111111111111112', // SOL
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC (–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å)
      1000000000 // 1 SOL
    );
    log(`‚úÖ Jupiter API working - got quote: ${testQuote ? 'success' : 'failed'}`);
    
    // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤
    await dailyTokenRefresh();
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Helius WebSocket —Å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–º —Å–∏–≥–Ω–∞–ª–æ–≤
    helius.onSwap = handleHeliusSignal;
    
    // –ó–∞–ø—É—Å–∫ Helius WebSocket
    await helius.connect();
    log('‚úÖ Helius WebSocket connected');
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–ø—É—Å–∫–µ
    await tg.sendMessage(`üöÄ **Hybrid Solana Signal Bot Started!**

üìä **Analysis Mode:** CoinGecko + Helius
üéØ **Strategy:** Daily token refresh + Real-time monitoring
‚öôÔ∏è **Monitoring:** ${tokenAnalyzer.getMonitoredTokens().length} tokens

üí° **API Optimization:**
‚Ä¢ CoinGecko: Once daily refresh (saves credits)
‚Ä¢ Helius: Real-time monitoring (uses available credits)

üîç **Ready for signal detection!**`);
    
    log('‚úÖ Hybrid initialization complete');
    
  } catch (error) {
    log(`‚ùå Initialization failed: ${error}`, 'ERROR');
    throw error;
  }
}

/**
 * –ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã
 */
async function start() {
  try {
    await initialize();
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤ (—Ä–∞–∑ –≤ 24 —á–∞—Å–∞)
    setInterval(dailyTokenRefresh, 24 * 60 * 60 * 1000);
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É (–∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç)
    setInterval(async () => {
      try {
        await diagnostics.runDiagnostics();
      } catch (error) {
        log(`Error in diagnostics: ${error}`, 'ERROR');
      }
    }, 10 * 60 * 1000);
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º –æ—Ç—á–µ—Ç—ã –æ–± –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ (–∫–∞–∂–¥—ã–µ 6 —á–∞—Å–æ–≤)
    setInterval(async () => {
      try {
        const monitoredCount = tokenAnalyzer.getMonitoredTokens().length;
        await sendDailyReport(monitoredCount);
      } catch (error) {
        log(`Error in activity report: ${error}`, 'ERROR');
      }
    }, 6 * 60 * 60 * 1000);
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º WebSocket –æ—Ç—á–µ—Ç—ã (–∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç)
    setInterval(async () => {
      try {
        await helius.sendWebSocketActivityReport();
      } catch (error) {
        log(`Error in WebSocket activity report: ${error}`, 'ERROR');
      }
    }, 10 * 60 * 1000);
    
    log('üéØ Hybrid Signal Bot is running...');
    
  } catch (error) {
    log(`‚ùå Failed to start: ${error}`, 'ERROR');
    process.exit(1);
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
process.on('SIGINT', async () => {
  log('üõë Shutting down Hybrid Signal Bot...');
  
  // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
  try {
    await tg.sendMessage(`üõë **Signal Bot Shutting Down**

‚ö†Ô∏è **Manual shutdown detected (SIGINT)**
üîÑ **Status:** Gracefully stopping all services...

üìä **Final Stats:**
‚Ä¢ Uptime: ${Math.floor(process.uptime() / 60)} minutes
‚Ä¢ Monitored Tokens: ${tokenAnalyzer.getMonitoredTokens().length}
‚Ä¢ API Usage: CoinGecko ${apiUsageStats.coingecko.dailyUsage}/333

üîå **Disconnecting services...**`);
  } catch (error) {
    log(`Error sending shutdown notification: ${error}`, 'ERROR');
  }
  
  await helius.disconnect();
  await db.close();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  log('üõë Shutting down Hybrid Signal Bot...');
  
  // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—Å—Ç–∞–Ω–æ–≤–∫–µ
  try {
    await tg.sendMessage(`üõë **Signal Bot Shutting Down**

‚ö†Ô∏è **System shutdown detected (SIGTERM)**
üîÑ **Status:** Gracefully stopping all services...

üìä **Final Stats:**
‚Ä¢ Uptime: ${Math.floor(process.uptime() / 60)} minutes
‚Ä¢ Monitored Tokens: ${tokenAnalyzer.getMonitoredTokens().length}
‚Ä¢ API Usage: CoinGecko ${apiUsageStats.coingecko.dailyUsage}/333

üîå **Disconnecting services...**`);
  } catch (error) {
    log(`Error sending shutdown notification: ${error}`, 'ERROR');
  }
  
  await helius.disconnect();
  await db.close();
  process.exit(0);
});

// –ó–∞–ø—É—Å–∫
start().catch(console.error); 