// token-analyzer.ts - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Ç–æ–∫–µ–Ω–æ–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º API –ª–∏–º–∏—Ç–æ–≤
import { CoinGeckoAPI, SolanaToken } from './coingecko';
import { JupiterAPI } from './jupiter';
import { Database } from './database';
import { calculateIndicators, checkBuySignal } from './indicators';
import { log } from './utils';
import { OHLCVRow } from './types';

export interface TokenAnalysisResult {
  mint: string;
  symbol: string;
  name: string;
  passesBasicFilters: boolean;
  passesTechnicalAnalysis: boolean;
  passesLiquidityTest: boolean;
  isSignal: boolean;
  reasons: string[];
  data: {
    emaBull?: boolean;
    rsi?: number;
    atr?: number;
    volumeSpike?: number;
    netFlow?: number;
    uniqueBuyers?: number;
    liquidityBoost?: boolean;
    avgVol60m?: number;
    vol5m?: number;
  };
}

export interface AnalysisConfig {
  minTokenAgeDays: number;
  minLiquidityUsd: number;
  maxFdvUsd: number;
  minVolumeSpike: number;
  maxRsiOversold: number;
  maxPriceImpactPercent: number;
  priceImpactTestAmount: number;
}

// –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å RollingMetrics
interface RollingMetrics {
  candles: OHLCVRow[];
  lastCandleTs: number;
  buyers5m: Set<string>;
  buyVol5m: number;
  sellVol5m: number;
  swapHistory: Array<{ts: number, buyer: string, buy: number, sell: number, amountUsd: number}>;
  lastSignalTs: number;
  lastDepositTs: number;
  liquidityBoost: boolean;
}

export class TokenAnalyzer {
  private coingecko: CoinGeckoAPI;
  private jupiter: JupiterAPI;
  private database: Database;
  private config: AnalysisConfig;
  
  // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è API –ª–∏–º–∏—Ç–æ–≤
  private topTokensCache: SolanaToken[] = [];
  private topTokensCacheTime = 0;
  private topTokensCacheTimeout = 48 * 60 * 60 * 1000; // 48 —á–∞—Å–æ–≤ –¥–ª—è CoinGecko (—Ç–æ–ø-2000 —Å—Ç–∞–±–∏–ª—å–Ω—ã)
  
  // Helius –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
  private monitoredTokens: Set<string> = new Set();
  private lastFullRefresh = 0;
  private fullRefreshInterval = 48 * 60 * 60 * 1000; // 48 —á–∞—Å–æ–≤
  
  private batchSize = 20; // –£–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä –±–∞—Ç—á–∞ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ CoinGecko
  private analysisInterval = 10 * 60 * 1000; // 10 –º–∏–Ω—É—Ç –º–µ–∂–¥—É –∞–Ω–∞–ª–∏–∑–∞–º–∏
  private lastAnalysisTime = 0;

  // –í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
  private forceRefreshMode = false; // –û–¢–ö–õ–Æ–ß–ê–ï–ú –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û–ï –û–ë–ù–û–í–õ–ï–ù–ò–ï

  private rolling: Map<string, RollingMetrics> = new Map();

  constructor(
    coingecko: CoinGeckoAPI,
    jupiter: JupiterAPI,
    database: Database,
    config: AnalysisConfig
  ) {
    this.coingecko = coingecko;
    this.jupiter = jupiter;
    this.database = database;
    this.config = config;
  }

  /**
   * –ì–ª–∞–≤–Ω—ã–π –º–µ—Ç–æ–¥ - –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–ø —Ç–æ–∫–µ–Ω—ã (—Å–Ω–∞—á–∞–ª–∞ –∏–∑ –±–∞–∑—ã, –ø–æ—Ç–æ–º –∏–∑ CoinGecko)
   */
  async getTopTokensForMonitoring(): Promise<SolanaToken[]> {
    try {
      const now = Date.now();
      
      // –ü–†–û–í–ï–†–Ø–ï–ú –†–ï–ñ–ò–ú –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û–ì–û –û–ë–ù–û–í–õ–ï–ù–ò–Ø
      if (this.forceRefreshMode) {
        log('üîÑ FORCE REFRESH MODE: Skipping cache and database, fetching fresh tokens from CoinGecko...');
        
        // –°–æ–∑–¥–∞–µ–º callback –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞—Ç—á–µ–π
        const saveBatchCallback = async (batch: SolanaToken[]): Promise<void> => {
          try {
            log(`üîÑ FORCE SAVE BATCH: Saving ${batch.length} tokens immediately to database...`);
            await this.saveTokensToCoinData(batch);
            log(`‚úÖ FORCE SAVE BATCH: Successfully saved ${batch.length} tokens to database`);
          } catch (error) {
            log(`‚ùå FORCE SAVE BATCH ERROR: ${error}`, 'ERROR');
          }
        };
        
        // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ø-2000 —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞–ø—Ä—è–º—É—é –∏–∑ CoinGecko —Å callback –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        const tokens = await this.coingecko.getTopSolanaTokens(2000, saveBatchCallback);
        log(`CoinGecko returned ${tokens.length} tokens in force refresh mode`);
        
        if (tokens.length === 0) {
          log('No tokens received from CoinGecko in force refresh mode', 'WARN');
          return this.topTokensCache; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∫—ç—à
        }

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
        const filteredTokens = this.applyBasicFilters(tokens);
        log(`Force refresh: ${filteredTokens.length} tokens after basic filters`);

        // –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        this.topTokensCache = filteredTokens;
        this.topTokensCacheTime = now;
        this.lastFullRefresh = now;

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        this.updateMonitoredTokens(filteredTokens);

        log(`‚úÖ Force refresh complete: ${filteredTokens.length} tokens cached for monitoring`);
        return filteredTokens;
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à –≤ –ø–∞–º—è—Ç–∏ (–±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
      if (this.topTokensCache.length > 0 && 
          now - this.topTokensCacheTime < this.topTokensCacheTimeout) {
        log('Using cached top tokens list (memory cache)');
        return this.topTokensCache;
      }

      log('üîÑ Token refresh: Checking database first...');
      
      // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö - –µ—Å—Ç—å –ª–∏ —Å–≤–µ–∂–∏–µ —Ç–æ–∫–µ–Ω—ã (24 —á–∞—Å–∞)
      const hasFreshTokens = await this.database.hasFreshTokens('Solana', 1500, 24);
      
      if (hasFreshTokens) {
        log('‚úÖ Found fresh tokens in database, using them instead of CoinGecko');
        const tokens = await this.loadTokensFromDatabase();
        
        if (tokens.length > 0) {
          // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
          const filteredTokens = this.applyBasicFilters(tokens);
          log(`Database refresh: ${filteredTokens.length} tokens after basic filters`);

          // –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
          this.topTokensCache = filteredTokens;
          this.topTokensCacheTime = now;
          this.lastFullRefresh = now;

          // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
          this.updateMonitoredTokens(filteredTokens);

          log(`‚úÖ Database refresh complete: ${filteredTokens.length} tokens cached for monitoring`);
          return filteredTokens;
        }
      }

      // –ï—Å–ª–∏ –≤ –±–∞–∑–µ –Ω–µ—Ç —Å–≤–µ–∂–∏—Ö —Ç–æ–∫–µ–Ω–æ–≤ - –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º CoinGecko
      log('üîÑ No fresh tokens in database, fetching from CoinGecko...');
      
      // –°–æ–∑–¥–∞–µ–º callback –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –±–∞—Ç—á–µ–π
      const saveBatchCallback = async (batch: SolanaToken[]): Promise<void> => {
        try {
          log(`üîÑ SAVE BATCH: Saving ${batch.length} tokens immediately to database...`);
          await this.saveTokensToCoinData(batch);
          log(`‚úÖ SAVE BATCH: Successfully saved ${batch.length} tokens to database`);
        } catch (error) {
          log(`‚ùå SAVE BATCH ERROR: ${error}`, 'ERROR');
        }
      };
      
      // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ø-2000 —Ç–æ–∫–µ–Ω–æ–≤ (—Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º) —Å callback –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
      const tokens = await this.coingecko.getTopSolanaTokens(2000, saveBatchCallback);
      log(`CoinGecko returned ${tokens.length} tokens`);
      
      if (tokens.length === 0) {
        log('No tokens received from CoinGecko', 'WARN');
        return this.topTokensCache; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∫—ç—à
      }

      // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
      const filteredTokens = this.applyBasicFilters(tokens);
      log(`CoinGecko refresh: ${filteredTokens.length} tokens after basic filters`);

      // –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      this.topTokensCache = filteredTokens;
      this.topTokensCacheTime = now;
      this.lastFullRefresh = now;

      // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
      this.updateMonitoredTokens(filteredTokens);

      log(`‚úÖ CoinGecko refresh complete: ${filteredTokens.length} tokens cached for monitoring`);
      return filteredTokens;
      
    } catch (error) {
      log(`Error in tokens refresh: ${error}`, 'ERROR');
      return this.topTokensCache; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∫—ç—à –ø—Ä–∏ –æ—à–∏–±–∫–µ
    }
  }

  /**
   * –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç–æ–∫–µ–Ω—ã –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö coin_data
   */
  private async loadTokensFromDatabase(): Promise<SolanaToken[]> {
    try {
      const freshTokens = await this.database.getFreshTokensFromCoinData('Solana', 24);
      
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –±–∞–∑—ã –≤ —Ñ–æ—Ä–º–∞—Ç SolanaToken
      // –í–ê–ñ–ù–û: –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ–∫–µ–Ω—ã —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ mint –∞–¥—Ä–µ—Å–∞–º–∏
      const tokens: SolanaToken[] = freshTokens
        .filter(row => row.mint && !row.mint.includes('placeholder')) // –¢–æ–ª—å–∫–æ —Ç–æ–∫–µ–Ω—ã —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ mint –∞–¥—Ä–µ—Å–∞–º–∏
        .map(row => ({
          coinId: row.coin_id, // –ò—Å–ø–æ–ª—å–∑—É–µ–º coin_id –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
          mint: row.mint, // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω—ã–µ mint –∞–¥—Ä–µ—Å–∞
          symbol: row.symbol || row.coin_id.toUpperCase(),
          name: row.name || row.coin_id,
          marketCap: row.market_cap || (row.price * 1000000),
          fdv: row.fdv || (row.price * 1000000),
          volume24h: row.volume,
          priceUsd: row.price,
          priceChange24h: 0,
          age: 15, // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º —á—Ç–æ —Ç–æ–∫–µ–Ω—ã –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ç–∞—Ä—ã–µ
          lastUpdated: row.timestamp
        }));

      log(`üìä Loaded ${tokens.length} tokens from coin_data table`);
      return tokens;
    } catch (error) {
      log(`Error loading tokens from database: ${error}`, 'ERROR');
      return [];
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω—ã –≤ coin_data —Ç–∞–±–ª–∏—Ü—É
   */
  private async saveTokensToCoinData(tokens: SolanaToken[]): Promise<void> {
    try {
      log(`üîÑ Preparing ${tokens.length} tokens for database save...`);
      log(`TOKENS TO SAVE COUNT: ${tokens.length}`);
      log(`TOKENS TO SAVE SAMPLE: ${tokens.slice(0, 10).map(t => t.symbol + ':' + t.mint).join(', ')}`);
      
      const coinDataTokens = tokens.map(token => ({
        coinId: token.coinId, // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π coinId –∏–∑ CoinGecko API
        mint: token.mint,
        symbol: token.symbol,
        name: token.name,
        network: 'Solana',
        price: token.priceUsd,
        volume: token.volume24h,
        marketCap: token.marketCap,
        fdv: token.fdv
      }));

      log(`üìã Sample tokens to save:`);
      coinDataTokens.slice(0, 3).forEach((token, i) => {
        log(`${i + 1}. ${token.symbol} (${token.coinId}) - mint: "${token.mint}" - price: $${token.price}`);
      });

      log(`üîÑ Calling database.saveCoinDataBatch with ${coinDataTokens.length} tokens...`);
      log(`üîÑ Database connection status: ${this.database ? 'Connected' : 'Not connected'}`);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å —Ç–æ–∫–µ–Ω—ã –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
      if (coinDataTokens.length === 0) {
        log(`‚ö†Ô∏è WARNING: No tokens to save! Original tokens array length: ${tokens.length}`);
        return;
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —Ç–æ–∫–µ–Ω—ã –∏–º–µ—é—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–æ–ª—è
      const validTokens = coinDataTokens.filter(token => 
        token.coinId && token.mint && token.symbol && token.name
      );
      
      if (validTokens.length !== coinDataTokens.length) {
        log(`‚ö†Ô∏è WARNING: ${coinDataTokens.length - validTokens.length} tokens have missing required fields`);
        log(`Valid tokens: ${validTokens.length}, Total tokens: ${coinDataTokens.length}`);
      }

      await this.database.saveCoinDataBatch(coinDataTokens);
      log(`üíæ Saved ${coinDataTokens.length} tokens to coin_data table`);
      log(`‚úÖ Database save operation completed successfully`);
      
    } catch (error) {
      log(`‚ùå Error saving tokens to coin_data: ${error}`, 'ERROR');
      if (error instanceof Error) {
        log(`‚ùå Error details: ${error.message}`);
        log(`‚ùå Error stack: ${error.stack}`);
      }
      
      // –ü–æ–ø—Ä–æ–±—É–µ–º —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–æ –æ–¥–Ω–æ–º—É –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
      log(`üîÑ Attempting individual saves for debugging...`);
      let savedCount = 0;
      for (const token of tokens.slice(0, 5)) { // –ü—Ä–æ–±—É–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 5
        try {
          await this.database.saveCoinData(
            token.coinId,
            token.mint,
            token.symbol,
            token.name,
            'Solana',
            token.priceUsd,
            token.volume24h,
            token.marketCap,
            token.fdv
          );
          savedCount++;
          log(`‚úÖ Individual save successful for ${token.symbol}`);
        } catch (individualError) {
          log(`‚ùå Failed to save token ${token.symbol}: ${individualError}`, 'ERROR');
        }
      }
      log(`Individual save result: ${savedCount}/5 tokens saved`);
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω—ã –≤ coin_data —Ç–∞–±–ª–∏—Ü—É –≤ –ø–∞–∫–µ—Ç–∞—Ö
   */
  private async saveTokensInBatches(tokens: SolanaToken[], batchSize: number): Promise<void> {
    try {
      log(`üîÑ Starting batch save of ${tokens.length} tokens in batches of ${batchSize}...`);
      
      const batches = this.createBatches(tokens, batchSize);
      log(`üì¶ Created ${batches.length} batches for saving`);
      
      let totalSaved = 0;
      let totalBatches = batches.length;
      
      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        try {
          log(`üîÑ Saving batch ${i + 1}/${totalBatches} with ${batch.length} tokens...`);
          await this.saveTokensToCoinData(batch);
          totalSaved += batch.length;
          log(`‚úÖ Successfully saved batch ${i + 1}/${totalBatches} (${batch.length} tokens). Total saved: ${totalSaved}/${tokens.length}`);
        } catch (error) {
          log(`‚ùå Error saving batch ${i + 1}/${totalBatches} (${batch.length} tokens): ${error}`, 'ERROR');
          if (error instanceof Error) {
            log(`‚ùå Error details: ${error.message}`);
          }
          // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å —Å–ª–µ–¥—É—é—â–∏–º –±–∞—Ç—á–µ–º, –Ω–µ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–µ—Å—å –ø—Ä–æ—Ü–µ—Å—Å
        }
      }
      
      log(`‚úÖ Batch save completed: ${totalSaved}/${tokens.length} tokens saved successfully`);
      
    } catch (error) {
      log(`‚ùå Critical error in batch save process: ${error}`, 'ERROR');
      throw error;
    }
  }

  /**
   * –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —á–µ—Ä–µ–∑ Helius
   */
  private updateMonitoredTokens(tokens: SolanaToken[]): void {
    this.monitoredTokens.clear();
    for (const token of tokens) {
      this.monitoredTokens.add(token.mint);
      this.ensureRolling(token.mint); // –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º rolling
    }
    log(`Updated monitoring list: ${this.monitoredTokens.size} tokens`);
  }

  /**
   * –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ç–æ–∫–µ–Ω–∞–º–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
   */
  updateMonitoredTokensFromDatabase(tokens: SolanaToken[]): void {
    this.monitoredTokens.clear();
    for (const token of tokens) {
      this.monitoredTokens.add(token.mint);
      this.ensureRolling(token.mint); // –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º rolling
    }
    log(`Updated monitoring list from database: ${this.monitoredTokens.size} tokens`);
  }

  private ensureRolling(mint: string) {
    if (!this.rolling.has(mint)) {
      this.rolling.set(mint, {
        candles: [],
        lastCandleTs: 0,
        buyers5m: new Set(),
        buyVol5m: 0,
        sellVol5m: 0,
        swapHistory: [],
        lastSignalTs: 0,
        lastDepositTs: 0,
        liquidityBoost: false
      });
    }
    return this.rolling.get(mint)!;
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω—É–∂–Ω–æ –ª–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç—å —ç—Ç–æ—Ç —Ç–æ–∫–µ–Ω
   */
  shouldMonitorToken(mint: string): boolean {
    return this.monitoredTokens.has(mint);
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
   */
  getMonitoredTokens(): string[] {
    return Array.from(this.monitoredTokens);
  }

  /**
   * –ê–Ω–∞–ª–∏–∑ —Ç–æ–∫–µ–Ω–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Helius (–±–µ–∑ CoinGecko –∑–∞–ø—Ä–æ—Å–æ–≤)
   */
  async analyzeTokenFromHelius(mint: string): Promise<TokenAnalysisResult | null> {
    try {
      // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω–∞ –∏–∑ –∫—ç—à–∞
      const token = this.topTokensCache.find(t => t.mint === mint);
      if (!token) {
        return null;
      }

      const result: TokenAnalysisResult = {
        mint: token.mint,
        symbol: token.symbol,
        name: token.name,
        passesBasicFilters: true, // –£–∂–µ –ø—Ä–æ—à–µ–ª –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
        passesTechnicalAnalysis: false,
        passesLiquidityTest: false,
        isSignal: false,
        reasons: [],
        data: {
          emaBull: false,
          rsi: 0,
          atr: 0,
          volumeSpike: 0,
          netFlow: 0,
          uniqueBuyers: 0,
          liquidityBoost: false,
          avgVol60m: 0,
          vol5m: 0
        }
      };

      // 1. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Helius
      const technicalResult = await this.performTechnicalAnalysis(token);
      result.passesTechnicalAnalysis = technicalResult.passes;
      result.data.volumeSpike = technicalResult.volumeSpike;
      result.data.rsi = technicalResult.rsi;
      result.data.emaBull = technicalResult.emaSignal;
      
      if (!technicalResult.passes) {
        result.reasons.push(...technicalResult.reasons);
        return result;
      }

      // 2. –¢–µ—Å—Ç –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ Jupiter (–±—ã—Å—Ç—Ä—ã–π –∏ –¥–µ—à–µ–≤—ã–π)
      const liquidityResult = await this.performLiquidityTest(token);
      result.passesLiquidityTest = liquidityResult.passes;
      
      if (!liquidityResult.passes) {
        result.reasons.push(...liquidityResult.reasons);
        return result;
      }

      // 3. –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã - —ç—Ç–æ —Å–∏–≥–Ω–∞–ª!
      result.isSignal = true;
      result.reasons.push('All criteria met - BUY SIGNAL');
      
      return result;
      
    } catch (error) {
      log(`Error analyzing token ${mint}: ${error}`, 'ERROR');
      return null;
    }
  }

  /**
   * –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–≤–∞–ø–∞ –∏ –∞–Ω–∞–ª–∏–∑ —Å–∏–≥–Ω–∞–ª–∞
   */
  async analyzeTokenActivity(mint: string, swapData: any): Promise<TokenAnalysisResult | null> {
    if (!this.shouldMonitorToken(mint)) return null;
    const rolling = this.ensureRolling(mint);
    const now = Math.floor(Date.now() / 1000);
    // 1. –û–±–Ω–æ–≤–ª—è–µ–º –º–∏–Ω—É—Ç–Ω—É—é —Å–≤–µ—á—É
    const minuteTs = Math.floor(swapData.timestamp / 60) * 60;
    let candle = rolling.candles.length > 0 && rolling.lastCandleTs === minuteTs ? rolling.candles[rolling.candles.length - 1] : null;
    if (!candle) {
      candle = { mint, ts: minuteTs, o: swapData.priceUsd, h: swapData.priceUsd, l: swapData.priceUsd, c: swapData.priceUsd, v: 0 };
      rolling.candles.push(candle);
      rolling.lastCandleTs = minuteTs;
      if (rolling.candles.length > 120) rolling.candles.shift();
    }
    candle.h = Math.max(candle.h, swapData.priceUsd);
    candle.l = Math.min(candle.l, swapData.priceUsd);
    candle.c = swapData.priceUsd;
    candle.v += swapData.volumeUsd;
    // 2. –û–±–Ω–æ–≤–ª—è–µ–º swapHistory (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 120 —Å–≤–∞–ø–æ–≤)
    rolling.swapHistory.push({ ts: swapData.timestamp, buyer: swapData.buyer || '', buy: swapData.buy || 0, sell: swapData.sell || 0, amountUsd: swapData.volumeUsd });
    if (rolling.swapHistory.length > 120) rolling.swapHistory.shift();
    // 3. Iceberg: —Å–≤–∞–ø—ã < $50 –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ–º –≤ –æ–±—ä—ë–º–µ, –Ω–æ —Å—á–∏—Ç–∞–µ–º –¥–ª—è UniqueBuyers
    if (swapData.volumeUsd >= 50) {
      if (swapData.buy) rolling.buyVol5m += swapData.volumeUsd;
      if (swapData.sell) rolling.sellVol5m += swapData.volumeUsd;
    }
    if (swapData.buyer) rolling.buyers5m.add(swapData.buyer);
    // 4. LP —Å–æ–±—ã—Ç–∏—è
    if (swapData.depositUsd && swapData.depositUsd > 5000) {
      rolling.lastDepositTs = swapData.timestamp;
      rolling.liquidityBoost = true;
    }
    // 5. –û–∫–Ω–∞ rolling (–æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö)
    const cutoff5m = now - 5 * 60;
    rolling.buyers5m = new Set(rolling.swapHistory.filter(s => s.ts >= cutoff5m).map(s => s.buyer));
    rolling.buyVol5m = rolling.swapHistory.filter(s => s.ts >= cutoff5m && s.buy).reduce((a, b) => a + b.amountUsd, 0);
    rolling.sellVol5m = rolling.swapHistory.filter(s => s.ts >= cutoff5m && s.sell).reduce((a, b) => a + b.amountUsd, 0);
    // 6. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    const candles = rolling.candles;
    const closes = candles.map(c => c.c);
    const ema12 = this.calculateEMA(closes, 12);
    const ema26 = this.calculateEMA(closes, 26);
    const emaBull = ema12.length > 0 && ema26.length > 0 && ema12[ema12.length - 1] > ema26[ema26.length - 1];
    const rsi = this.calculateRSI(closes, 14);
    const atr = this.calculateATR(candles, 14);
    // 7. –ü–æ—Ç–æ–∫–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏
    const vol60m = candles.slice(-60).reduce((a, c) => a + c.v, 0);
    const avgVol60m = vol60m / Math.max(1, candles.slice(-60).length);
    const vol5m = candles.slice(-5).reduce((a, c) => a + c.v, 0);
    const avgVol30m = candles.slice(-30, -5).reduce((a, c) => a + c.v, 0) / 25;
    const volumeSpike = avgVol30m > 0 ? vol5m / (avgVol30m * 5) : 0;
    const netFlow = rolling.sellVol5m > 0 ? rolling.buyVol5m / rolling.sellVol5m : 0;
    const uniqueBuyers = rolling.buyers5m.size;
    // 8. LP boost
    const liquidityBoost = rolling.liquidityBoost && (now - rolling.lastDepositTs < 10 * 60);
    // 9. –§–∏–ª—å—Ç—Ä—ã –¥–æ–ø—É—Å–∫–∞
    const poolAgeOk = true; // TODO: –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –≤–æ–∑—Ä–∞—Å—Ç–∞ –ø—É–ª–∞ (first_seen_ts)
    const hasUsdcOrSol = true; // TODO: –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –ø–æ tokenTransfers
    const avgVolOk = avgVol60m >= 2000;
    // 10. –°–∏–≥–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
    let isSignal = false;
    let reasons: string[] = [];
    if (
      volumeSpike >= this.config.minVolumeSpike ||
      uniqueBuyers >= this.config.minLiquidityUsd ||
      netFlow > 0 ||
      rsi <= this.config.maxRsiOversold ||
      emaBull ||
      liquidityBoost ||
      avgVol60m >= this.config.minLiquidityUsd ||
      vol5m >= this.config.minLiquidityUsd / 10
    ) {
      if (now - rolling.lastSignalTs > 30 * 60) {
        isSignal = true;
        rolling.lastSignalTs = now;
        reasons.push('All criteria met - BUY SIGNAL');
      }
    }
    if (rsi > 70 || netFlow < 1) {
      reasons.push('SELL/exit condition met');
    }
    // 11. –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    return {
      mint,
      symbol: '',
      name: '',
      passesBasicFilters: true,
      passesTechnicalAnalysis: true,
      passesLiquidityTest: true,
      isSignal,
      reasons,
      data: {
        emaBull,
        rsi,
        atr,
        volumeSpike,
        netFlow,
        uniqueBuyers,
        liquidityBoost,
        avgVol60m,
        vol5m
      }
    };
  }

  /**
   * –ü—Ä–∏–º–µ–Ω–∏—Ç—å –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã (–±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö API –∑–∞–ø—Ä–æ—Å–æ–≤)
   */
  private applyBasicFilters(tokens: SolanaToken[]): SolanaToken[] {
    return tokens.filter(token => {
      // –í–æ–∑—Ä–∞—Å—Ç >= 14 –¥–Ω–µ–π (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ, –æ—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ –¥–∞–Ω–Ω—ã—Ö CoinGecko)
      const ageCheck = true; // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —Ç–æ–ø —Ç–æ–∫–µ–Ω—ã –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ç–∞—Ä—ã–µ
      
      // –õ–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å >= $10k (–∏—Å–ø–æ–ª—å–∑—É–µ–º volume24h –∫–∞–∫ –ø—Ä–æ–∫—Å–∏)
      const liquidityCheck = token.volume24h >= this.config.minLiquidityUsd;
      
      // FDV <= $5M
      const fdvCheck = token.fdv <= this.config.maxFdvUsd;
      
      // –ë–∞–∑–æ–≤—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
      const basicCheck = token.mint && token.symbol && token.priceUsd > 0;
      
      return ageCheck && liquidityCheck && fdvCheck && basicCheck;
    });
  }

  /**
   * –°–æ–∑–¥–∞—Ç—å –±–∞—Ç—á–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
   */
  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–∞—Ç—á —Ç–æ–∫–µ–Ω–æ–≤
   */
  private async analyzeBatch(tokens: SolanaToken[]): Promise<TokenAnalysisResult[]> {
    const results: TokenAnalysisResult[] = [];
    
    for (const token of tokens) {
      try {
        const result = await this.analyzeToken(token);
        results.push(result);
        
        // –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É —Ç–æ–∫–µ–Ω–∞–º–∏
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        log(`Error analyzing token ${token.symbol}: ${error}`, 'ERROR');
        
        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ—É–¥–∞—á–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        results.push({
          mint: token.mint,
          symbol: token.symbol,
          name: token.name,
          passesBasicFilters: false,
          passesTechnicalAnalysis: false,
          passesLiquidityTest: false,
          isSignal: false,
          reasons: ['Analysis failed'],
          data: {
            emaBull: false,
            rsi: 0,
            atr: 0,
            volumeSpike: 0,
            netFlow: 0,
            uniqueBuyers: 0,
            liquidityBoost: false,
            avgVol60m: 0,
            vol5m: 0
          }
        });
      }
    }
    
    return results;
  }

  /**
   * –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ–¥–∏–Ω —Ç–æ–∫–µ–Ω
   */
  private async analyzeToken(token: SolanaToken): Promise<TokenAnalysisResult> {
    const result: TokenAnalysisResult = {
      mint: token.mint,
      symbol: token.symbol,
      name: token.name,
      passesBasicFilters: true, // –£–∂–µ –ø—Ä–æ—à–µ–ª –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
      passesTechnicalAnalysis: false,
      passesLiquidityTest: false,
      isSignal: false,
      reasons: [],
      data: {
        emaBull: false,
        rsi: 0,
        atr: 0,
        volumeSpike: 0,
        netFlow: 0,
        uniqueBuyers: 0,
        liquidityBoost: false,
        avgVol60m: 0,
        vol5m: 0
      }
    };

    // 1. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑
    const technicalResult = await this.performTechnicalAnalysis(token);
    result.passesTechnicalAnalysis = technicalResult.passes;
    result.data.volumeSpike = technicalResult.volumeSpike;
    result.data.rsi = technicalResult.rsi;
    result.data.emaBull = technicalResult.emaSignal;
    
    if (!technicalResult.passes) {
      result.reasons.push(...technicalResult.reasons);
      return result;
    }

    // 2. –¢–µ—Å—Ç –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –∏ price impact
    const liquidityResult = await this.performLiquidityTest(token);
    result.passesLiquidityTest = liquidityResult.passes;
    
    if (!liquidityResult.passes) {
      result.reasons.push(...liquidityResult.reasons);
      return result;
    }

    // 3. –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã - —ç—Ç–æ —Å–∏–≥–Ω–∞–ª!
    result.isSignal = true;
    result.reasons.push('All criteria met - BUY SIGNAL');
    
    return result;
  }

  /**
   * –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Ç–æ–∫–µ–Ω–∞
   */
  private async performTechnicalAnalysis(token: SolanaToken): Promise<{
    passes: boolean;
    reasons: string[];
    volumeSpike?: number;
    rsi?: number;
    emaSignal?: boolean;
  }> {
    try {
      // –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –±–∞–∑—ã
      const candles = await this.database.getCandles(token.mint, 40);
      
      if (candles.length < 30) {
        return {
          passes: false,
          reasons: ['Insufficient historical data']
        };
      }

      // –í—ã—á–∏—Å–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
      const indicators = calculateIndicators(candles);
      if (!indicators) {
        return {
          passes: false,
          reasons: ['Failed to calculate indicators']
        };
      }

      const reasons: string[] = [];
      let passes = true;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—ä–µ–º-—Å–ø–∞–π–∫ √ó3
      if (indicators.volSpike < this.config.minVolumeSpike) {
        passes = false;
        reasons.push(`Volume spike too low: ${indicators.volSpike.toFixed(2)}x < ${this.config.minVolumeSpike}x`);
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º RSI –≤—ã—Ö–æ–¥ –∏–∑ –∑–æ–Ω—ã < 35
      if (indicators.rsi <= this.config.maxRsiOversold) {
        passes = false;
        reasons.push(`RSI still oversold: ${indicators.rsi.toFixed(2)} <= ${this.config.maxRsiOversold}`);
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º EMA –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ
      if (!checkBuySignal(indicators)) {
        passes = false;
        reasons.push('EMA-9/21 not crossed up');
      }

      return {
        passes,
        reasons,
        volumeSpike: indicators.volSpike,
        rsi: indicators.rsi,
        emaSignal: checkBuySignal(indicators)
      };
      
    } catch (error) {
      return {
        passes: false,
        reasons: [`Technical analysis error: ${error}`]
      };
    }
  }

  /**
   * –¢–µ—Å—Ç –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –∏ price impact
   */
  private async performLiquidityTest(token: SolanaToken): Promise<{
    passes: boolean;
    reasons: string[];
    priceImpact?: number;
    liquidity?: number;
  }> {
    try {
      // –ü–æ–ª—É—á–∞–µ–º quote –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏–∏ —Å–≤–∞–ø–∞
      const quote = await this.jupiter.getQuote(
        'So11111111111111111111111111111111111111112', // SOL
        token.mint,
        this.config.priceImpactTestAmount * 1e9 // Convert to lamports
      );

      if (!quote) {
        return {
          passes: false,
          reasons: ['No liquidity - Jupiter quote failed']
        };
      }

      // –í—ã—á–∏—Å–ª—è–µ–º price impact
      const priceImpact = this.calculatePriceImpact(quote);
      
      // –û—Ü–µ–Ω–∫–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ slippage
      const liquidity = this.estimateLiquidity(quote, priceImpact);

      const reasons: string[] = [];
      let passes = true;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å >= $10k
      if (liquidity < this.config.minLiquidityUsd) {
        passes = false;
        reasons.push(`Liquidity too low: $${liquidity.toFixed(0)} < $${this.config.minLiquidityUsd}`);
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º price impact <= 3%
      if (priceImpact > this.config.maxPriceImpactPercent) {
        passes = false;
        reasons.push(`Price impact too high: ${priceImpact.toFixed(2)}% > ${this.config.maxPriceImpactPercent}%`);
      }

      return {
        passes,
        reasons,
        priceImpact,
        liquidity
      };
      
    } catch (error) {
      return {
        passes: false,
        reasons: [`Liquidity test error: ${error}`]
      };
    }
  }

  /**
   * –í—ã—á–∏—Å–ª–∏—Ç—å price impact –∏–∑ quote
   */
  private calculatePriceImpact(quote: any): number {
    try {
      // Jupiter quote —Å–æ–¥–µ—Ä–∂–∏—Ç priceImpactPct
      if (quote.priceImpactPct) {
        return Math.abs(parseFloat(quote.priceImpactPct));
      }
      
      // Fallback - –≤—ã—á–∏—Å–ª—è–µ–º –∏–∑ routePlan
      if (quote.routePlan && quote.routePlan.length > 0) {
        const route = quote.routePlan[0];
        if (route.swapInfo && route.swapInfo.feeAmount && route.swapInfo.inAmount) {
          return (parseFloat(route.swapInfo.feeAmount) / parseFloat(route.swapInfo.inAmount)) * 100;
        }
      }
      
      return 0;
    } catch (error) {
      return 100; // High impact if can't calculate
    }
  }

  /**
   * –û—Ü–µ–Ω–∏—Ç—å –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ quote
   */
  private estimateLiquidity(quote: any, priceImpact: number): number {
    try {
      // –ü—Ä–æ—Å—Ç–∞—è –æ—Ü–µ–Ω–∫–∞: –µ—Å–ª–∏ price impact –Ω–∏–∑–∫–∏–π, –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –≤—ã—Å–æ–∫–∞—è
      if (priceImpact < 0.5) return 50000; // High liquidity
      if (priceImpact < 1.0) return 25000; // Medium liquidity
      if (priceImpact < 2.0) return 15000; // Low-medium liquidity
      if (priceImpact < 3.0) return 10000; // Low liquidity
      return 5000; // Very low liquidity
    } catch (error) {
      return 0;
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
   */
  getConfig(): AnalysisConfig {
    return { ...this.config };
  }

  /**
   * –û–±–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
   */
  updateConfig(newConfig: Partial<AnalysisConfig>): void {
    this.config = { ...this.config, ...newConfig };
    log('Token analyzer config updated');
  }

  // ... —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å calculateEMA, calculateRSI, calculateATR (–º–æ–∂–Ω–æ –≤–∑—è—Ç—å –∏–∑ indicators.ts)
  private calculateEMA(prices: number[], period: number): number[] {
    const ema: number[] = [];
    let multiplier = 2 / (period + 1);
    let currentEMA = prices[0];
    ema.push(currentEMA);

    for (let i = 1; i < prices.length; i++) {
      currentEMA = prices[i] * multiplier + currentEMA * (1 - multiplier);
      ema.push(currentEMA);
    }
    return ema;
  }

  private calculateRSI(prices: number[], period: number): number {
    let gains = 0;
    let losses = 0;
    let avgGain = 0;
    let avgLoss = 0;

    for (let i = 1; i <= period; i++) {
      const diff = prices[i] - prices[i - 1];
      if (diff > 0) {
        gains += diff;
      } else {
        losses -= diff;
      }
    }

    avgGain = gains / period;
    avgLoss = losses / period;

    let rsi = 0;
    if (avgLoss === 0) {
      rsi = 100;
    } else {
      rsi = 100 - (100 / (1 + avgGain / avgLoss));
    }
    return rsi;
  }

  private calculateATR(candles: OHLCVRow[], period: number): number {
    let tr = 0;
    for (let i = 1; i < candles.length; i++) {
      const high = candles[i].h;
      const low = candles[i].l;
      const prevClose = candles[i - 1].c;

      tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
    }
    return tr;
  }
} 